[{"path":"index.html","id":"overview","chapter":"1 Overview","heading":"1 Overview","text":"","code":""},{"path":"index.html","id":"subgroups","chapter":"1 Overview","heading":"1.1 Subgroups","text":"","code":""},{"path":"index.html","id":"subgroups-by-timepoint","chapter":"1 Overview","heading":"1.1.1 Subgroups by timepoint","text":"deliberately broad protocol wasn’t clear conventional, feasible, study participants multiple timepoints.addition, studies reported change scores, opposed post-intervention outcomes. currently reading combine statistics, currently dividing change score post-intervention analyses separate subgroups.collected data timepoints baseline; post-intervention; change score; follow-. However, studies excluded due reporting statistics required include meta-analysis (e.g., sample size). look timepoints outcome, see post-intervention timepoint routinely reported:","code":""},{"path":"index.html","id":"interventions","chapter":"1 Overview","heading":"1.1.2 Interventions","text":"duloxetine others","code":""},{"path":"test.html","id":"test","chapter":"2 test","heading":"2 test","text":"","code":""},{"path":"test.html","id":"summary-of-findings","chapter":"2 test","heading":"2.1 Summary of findings","text":"","code":""},{"path":"test.html","id":"pairwise-comparisons","chapter":"2 test","heading":"2.2 Pairwise comparisons","text":"","code":""},{"path":"documentation.html","id":"documentation","chapter":"3 Documentation","heading":"3 Documentation","text":"","code":""},{"path":"documentation.html","id":"acr","chapter":"3 Documentation","heading":"3.1 ACR","text":"Let \\(k\\) denote outcome \\(\\) observation outcome, assumed comparator risk (ACR) calculated:\\[\n\\Sigma_{ki} r_{ki} / \\Sigma_{ki} n_{ki}\n\\]","code":""},{"path":"documentation.html","id":"calculations-for-missing-observations","chapter":"3 Documentation","heading":"3.2 Calculations for missing observations","text":"possible required statistics calculated reported statistics.Confidence intervals assumed \\(\\alpha = 0.05\\); .e., 95% confidence intervals assumed.medians interquartile ranges reported, means standard deviations estimated using implmentation (Gray 2021) (Wan et al. 2014)’s method.","code":""},{"path":"documentation.html","id":"direction-of-improvement","chapter":"3 Documentation","heading":"3.3 Direction of improvement","text":"assumed direction improvement outcome encoded direction_of_improvement (see table ). standardised mean difference smd outcomes, scale reported opposite assumed direction, mean set -mean.","code":""},{"path":"documentation.html","id":"are-the-converted-values-similar-to-the-raw-values","chapter":"3 Documentation","heading":"3.4 Are the converted values similar to the raw values?","text":"table, … scale outcome?","code":""},{"path":"documentation.html","id":"number-of-studies-extracted-175","chapter":"3 Documentation","heading":"3.5 Number of studies extracted: 175","text":"","code":""},{"path":"documentation.html","id":"excluded-observations-48-from-18-studies","chapter":"3 Documentation","heading":"3.6 Excluded observations: 48 from 18 studies","text":"odds-ratio rate sample size required NMA, standardised mean difference, mean, standard deviation, sample size required. missing reported statistics, required statistics calculated reported, observations excluded models.","code":""},{"path":"documentation.html","id":"random-sample-checked","chapter":"3 Documentation","heading":"3.7 Random sample checked","text":"","code":""},{"path":"pipeline.html","id":"pipeline","chapter":"4 Pipeline","heading":"4 Pipeline","text":"need pairwise NMA available data specifications foroutcomestimepointsclassdosetype comparison madeWe need verify data think , model output,\ncapture meta-data analysis. Crucially, plot output needs captured output meta-data, location model.clean data found mod_dat.","code":"\ntar_load(mod_dat)\n\nmod_dat %>% \n  dim()## [1] 3098   73\nmod_dat %>% sample_n(10) %>% head()"},{"path":"pipeline.html","id":"getting-data","chapter":"4 Pipeline","heading":"4.1 Getting data","text":"Based specific filters, want get data NMA PW.-[] Create get NMA dat fn.\n-[] Create get MA dat fn.\n- Resist urge combine two.\n-[] Create target test get NMA.\n-[] Create document.\n-[] Write example.\n-[] Write asserts tests based example.example, suppose wish toLet’s check function works .","code":""},{"path":"pipeline.html","id":"tasks","chapter":"4 Pipeline","heading":"4.2 Tasks","text":"[] Provide placebo vs duloxetine stratified dose","code":""},{"path":"pipeline.html","id":"placebo-vs-duloxetine","chapter":"4 Pipeline","heading":"4.2.1 Placebo vs duloxetine","text":"function identify studies contain comparators. Let’s check gives us number studies expect.Now studies , can capture observations.Check right number studies.Now need put data wide format. First check one placebo per study.Since one placebo per study, can bind placebo data data control. label control. Need capture various things, tricky part.Check many studies arms expected.Now need forest plot can stratified class, dose, condition.","code":"## [1] TRUE## [1] 22## [1] 22## [1] 32## [1] 32## Error in get_pw_dat(dat = mod_dat, outcome = \"pain_sub\", type = \"ad\", : unused argument (type = \"ad\")## function (yi, vi, sei, weights, ai, bi, ci, di, n1i, n2i, x1i, \n##     x2i, t1i, t2i, m1i, m2i, sd1i, sd2i, xi, mi, ri, ti, sdi, \n##     r2i, ni, mods, scale, measure = \"GEN\", intercept = TRUE, \n##     data, slab, subset, add = 1/2, to = \"only0\", drop00 = FALSE, \n##     vtype = \"LS\", method = \"REML\", weighted = TRUE, test = \"z\", \n##     level = 95, digits, btt, att, tau2, verbose = FALSE, control, \n##     ...) \n## {\n##     mstyle <- .get.mstyle(\"crayon\" %in% .packages())\n##     if (!is.element(measure, c(\"RR\", \"OR\", \"PETO\", \"RD\", \"AS\", \n##         \"PHI\", \"YUQ\", \"YUY\", \"RTET\", \"PBIT\", \"OR2D\", \"OR2DN\", \n##         \"OR2DL\", \"MPRD\", \"MPRR\", \"MPOR\", \"MPORC\", \"MPPETO\", \"IRR\", \n##         \"IRD\", \"IRSD\", \"MD\", \"SMD\", \"SMDH\", \"ROM\", \"CVR\", \"VR\", \n##         \"RPB\", \"RBIS\", \"D2OR\", \"D2ORN\", \"D2ORL\", \"COR\", \"UCOR\", \n##         \"ZCOR\", \"PCOR\", \"ZPCOR\", \"SPCOR\", \"PR\", \"PLN\", \"PLO\", \n##         \"PAS\", \"PFT\", \"IR\", \"IRLN\", \"IRS\", \"IRFT\", \"MN\", \"MNLN\", \n##         \"CVLN\", \"SDLN\", \"SMD1\", \"MC\", \"SMCC\", \"SMCR\", \"SMCRH\", \n##         \"ROMC\", \"CVRC\", \"VRC\", \"ARAW\", \"AHW\", \"ABT\", \"GEN\"))) \n##         stop(mstyle$stop(\"Unknown 'measure' specified.\"))\n##     if (!is.element(method, c(\"FE\", \"EE\", \"CE\", \"HS\", \"HSk\", \n##         \"HE\", \"DL\", \"DLIT\", \"GENQ\", \"GENQM\", \"SJ\", \"SJIT\", \"PM\", \n##         \"PMM\", \"ML\", \"REML\", \"EB\"))) \n##         stop(mstyle$stop(\"Unknown 'method' specified.\"))\n##     if (length(add) > 1L) \n##         add <- add[1]\n##     if (length(to) > 1L) \n##         to <- to[1]\n##     na.act <- getOption(\"na.action\")\n##     if (!is.element(na.act, c(\"na.omit\", \"na.exclude\", \"na.fail\", \n##         \"na.pass\"))) \n##         stop(mstyle$stop(\"Unknown 'na.action' specified under options().\"))\n##     if (missing(tau2)) \n##         tau2 <- NULL\n##     if (missing(control)) \n##         control <- list()\n##     time.start <- proc.time()\n##     ddd <- list(...)\n##     .chkdots(ddd, c(\"knha\", \"link\", \"alpha\", \"outlist\", \"onlyo1\", \n##         \"addyi\", \"addvi\", \"time\", \"skipr2\", \"skiphes\"))\n##     if (.isFALSE(ddd$knha)) \n##         test <- \"z\"\n##     if (.isTRUE(ddd$knha)) \n##         test <- \"knha\"\n##     if (!is.element(test, c(\"z\", \"t\", \"knha\", \"adhoc\"))) \n##         stop(mstyle$stop(\"Invalid option selected for 'test' argument.\"))\n##     if (missing(scale)) {\n##         model <- \"rma.uni\"\n##     }\n##     else {\n##         if (is.element(test, c(\"knha\", \"adhoc\"))) \n##             stop(mstyle$stop(\"Cannot use Knapp & Hartung method with location-scale models.\"))\n##         model <- \"rma.ls\"\n##     }\n##     if (!is.null(ddd$link)) {\n##         link <- match.arg(ddd$link, c(\"log\", \"identity\"))\n##     }\n##     else {\n##         link <- \"log\"\n##     }\n##     if (!is.null(ddd$alpha)) {\n##         alpha <- ddd$alpha\n##     }\n##     else {\n##         alpha <- NA\n##     }\n##     onlyo1 <- ifelse(is.null(ddd$onlyo1), FALSE, ddd$onlyo1)\n##     addyi <- ifelse(is.null(ddd$addyi), TRUE, ddd$addyi)\n##     addvi <- ifelse(is.null(ddd$addvi), TRUE, ddd$addvi)\n##     if (missing(digits)) {\n##         digits <- .set.digits(dmiss = TRUE)\n##     }\n##     else {\n##         digits <- .set.digits(digits, dmiss = FALSE)\n##     }\n##     formula.yi <- NULL\n##     formula.mods <- NULL\n##     formula.scale <- NULL\n##     if (verbose > 2) {\n##         opwarn <- options(warn = 1)\n##         on.exit(options(warn = opwarn$warn))\n##     }\n##     if (verbose && !exists(\".rmspace\")) \n##         cat(\"\\n\")\n##     if (verbose > 1) \n##         message(mstyle$message(\"Extracting/computing yi/vi values ...\"))\n##     if (missing(data)) \n##         data <- NULL\n##     if (is.null(data)) {\n##         data <- sys.frame(sys.parent())\n##     }\n##     else {\n##         if (!is.data.frame(data)) \n##             data <- data.frame(data)\n##     }\n##     mf <- match.call()\n##     addval <- mf[[match(\"add\", names(mf))]]\n##     if (is.element(measure, c(\"AS\", \"PHI\", \"RTET\", \"IRSD\", \"PAS\", \n##         \"PFT\", \"IRS\", \"IRFT\")) && is.null(addval)) \n##         add <- 0\n##     mf.yi <- mf[[match(\"yi\", names(mf))]]\n##     yi <- eval(mf.yi, data, enclos = sys.frame(sys.parent()))\n##     if (!is.null(yi) && inherits(yi, \"escalc\")) \n##         data <- yi\n##     mf.weights <- mf[[match(\"weights\", names(mf))]]\n##     mf.slab <- mf[[match(\"slab\", names(mf))]]\n##     mf.subset <- mf[[match(\"subset\", names(mf))]]\n##     mf.mods <- mf[[match(\"mods\", names(mf))]]\n##     mf.scale <- mf[[match(\"scale\", names(mf))]]\n##     weights <- eval(mf.weights, data, enclos = sys.frame(sys.parent()))\n##     slab <- eval(mf.slab, data, enclos = sys.frame(sys.parent()))\n##     subset <- eval(mf.subset, data, enclos = sys.frame(sys.parent()))\n##     mods <- eval(mf.mods, data, enclos = sys.frame(sys.parent()))\n##     scale <- eval(mf.scale, data, enclos = sys.frame(sys.parent()))\n##     ai <- bi <- ci <- di <- x1i <- x2i <- t1i <- t2i <- NA\n##     if (!is.null(yi)) {\n##         if (inherits(yi, \"formula\")) {\n##             formula.yi <- yi\n##             options(na.action = \"na.pass\")\n##             mods <- model.matrix(yi, data = data)\n##             attr(mods, \"assign\") <- NULL\n##             attr(mods, \"contrasts\") <- NULL\n##             yi <- model.response(model.frame(yi, data = data))\n##             options(na.action = na.act)\n##             names(yi) <- NULL\n##             intercept <- FALSE\n##         }\n##         if (inherits(yi, \"escalc\")) {\n##             if (!is.null(attr(yi, \"yi.names\"))) {\n##                 yi.name <- attr(yi, \"yi.names\")[1]\n##             }\n##             else {\n##                 if (!is.element(\"yi\", names(yi))) \n##                   stop(mstyle$stop(\"Cannot determine name of the 'yi' variable.\"))\n##                 yi.name <- \"yi\"\n##             }\n##             if (!is.null(attr(yi, \"vi.names\"))) {\n##                 vi.name <- attr(yi, \"vi.names\")[1]\n##             }\n##             else {\n##                 if (!is.element(\"vi\", names(yi))) \n##                   stop(mstyle$stop(\"Cannot determine name of the 'vi' variable.\"))\n##                 vi.name <- \"vi\"\n##             }\n##             vi <- yi[[vi.name]]\n##             yi <- yi[[yi.name]]\n##             yi.escalc <- TRUE\n##         }\n##         else {\n##             yi.escalc <- FALSE\n##         }\n##         if (is.matrix(yi)) \n##             yi <- as.vector(yi)\n##         k <- length(yi)\n##         k.all <- k\n##         if (measure == \"GEN\" && !is.null(attr(yi, \"measure\"))) \n##             measure <- attr(yi, \"measure\")\n##         attr(yi, \"measure\") <- measure\n##         if (!yi.escalc) {\n##             mf.vi <- mf[[match(\"vi\", names(mf))]]\n##             mf.sei <- mf[[match(\"sei\", names(mf))]]\n##             vi <- eval(mf.vi, data, enclos = sys.frame(sys.parent()))\n##             sei <- eval(mf.sei, data, enclos = sys.frame(sys.parent()))\n##         }\n##         mf.ni <- mf[[match(\"ni\", names(mf))]]\n##         ni <- eval(mf.ni, data, enclos = sys.frame(sys.parent()))\n##         if (is.null(vi)) {\n##             if (is.null(sei)) {\n##                 stop(mstyle$stop(\"Must specify 'vi' or 'sei' argument.\"))\n##             }\n##             else {\n##                 vi <- sei^2\n##             }\n##         }\n##         if (is.matrix(vi)) \n##             vi <- as.vector(vi)\n##         if ((length(vi) == 1L && vi == 0) || (length(vi) == k && \n##             !anyNA(vi) && all(vi == 0))) {\n##             vi0 <- TRUE\n##         }\n##         else {\n##             vi0 <- FALSE\n##         }\n##         if (length(vi) == 1L) \n##             vi <- rep(vi, k)\n##         if (length(vi) != k) \n##             stop(mstyle$stop(\"Length of 'yi' and 'vi' (or 'sei') is not the same.\"))\n##         if (is.null(ni) && !is.null(attr(yi, \"ni\"))) \n##             ni <- attr(yi, \"ni\")\n##         if (!is.null(ni) && length(ni) != k) \n##             ni <- NULL\n##         if (!is.null(ni)) \n##             attr(yi, \"ni\") <- ni\n##         if (is.null(slab)) {\n##             if (!is.null(attr(yi, \"slab\"))) \n##                 slab <- attr(yi, \"slab\")\n##             if (!is.null(slab) && length(slab) != k) \n##                 slab <- NULL\n##         }\n##         if (!is.null(subset)) {\n##             subset <- .setnafalse(subset, k = k)\n##             yi <- yi[subset]\n##             vi <- vi[subset]\n##             ni <- ni[subset]\n##             attr(yi, \"measure\") <- measure\n##             attr(yi, \"ni\") <- ni\n##         }\n##     }\n##     else {\n##         if (is.element(measure, c(\"RR\", \"OR\", \"PETO\", \"RD\", \"AS\", \n##             \"PHI\", \"YUQ\", \"YUY\", \"RTET\", \"PBIT\", \"OR2D\", \"OR2DN\", \n##             \"OR2DL\", \"MPRD\", \"MPRR\", \"MPOR\", \"MPORC\", \"MPPETO\"))) {\n##             mf.ai <- mf[[match(\"ai\", names(mf))]]\n##             mf.bi <- mf[[match(\"bi\", names(mf))]]\n##             mf.ci <- mf[[match(\"ci\", names(mf))]]\n##             mf.di <- mf[[match(\"di\", names(mf))]]\n##             mf.n1i <- mf[[match(\"n1i\", names(mf))]]\n##             mf.n2i <- mf[[match(\"n2i\", names(mf))]]\n##             ai <- eval(mf.ai, data, enclos = sys.frame(sys.parent()))\n##             bi <- eval(mf.bi, data, enclos = sys.frame(sys.parent()))\n##             ci <- eval(mf.ci, data, enclos = sys.frame(sys.parent()))\n##             di <- eval(mf.di, data, enclos = sys.frame(sys.parent()))\n##             n1i <- eval(mf.n1i, data, enclos = sys.frame(sys.parent()))\n##             n2i <- eval(mf.n2i, data, enclos = sys.frame(sys.parent()))\n##             if (is.null(bi)) \n##                 bi <- n1i - ai\n##             if (is.null(di)) \n##                 di <- n2i - ci\n##             k <- length(ai)\n##             k.all <- k\n##             if (!is.null(subset)) {\n##                 subset <- .setnafalse(subset, k = k)\n##                 ai <- ai[subset]\n##                 bi <- bi[subset]\n##                 ci <- ci[subset]\n##                 di <- di[subset]\n##             }\n##             dat <- escalc(measure = measure, ai = ai, bi = bi, \n##                 ci = ci, di = di, add = add, to = to, drop00 = drop00, \n##                 vtype = vtype, onlyo1 = onlyo1, addyi = addyi, \n##                 addvi = addvi)\n##         }\n##         if (is.element(measure, c(\"IRR\", \"IRD\", \"IRSD\"))) {\n##             mf.x1i <- mf[[match(\"x1i\", names(mf))]]\n##             mf.x2i <- mf[[match(\"x2i\", names(mf))]]\n##             mf.t1i <- mf[[match(\"t1i\", names(mf))]]\n##             mf.t2i <- mf[[match(\"t2i\", names(mf))]]\n##             x1i <- eval(mf.x1i, data, enclos = sys.frame(sys.parent()))\n##             x2i <- eval(mf.x2i, data, enclos = sys.frame(sys.parent()))\n##             t1i <- eval(mf.t1i, data, enclos = sys.frame(sys.parent()))\n##             t2i <- eval(mf.t2i, data, enclos = sys.frame(sys.parent()))\n##             k <- length(x1i)\n##             k.all <- k\n##             if (!is.null(subset)) {\n##                 subset <- .setnafalse(subset, k = k)\n##                 x1i <- x1i[subset]\n##                 x2i <- x2i[subset]\n##                 t1i <- t1i[subset]\n##                 t2i <- t2i[subset]\n##             }\n##             dat <- escalc(measure = measure, x1i = x1i, x2i = x2i, \n##                 t1i = t1i, t2i = t2i, add = add, to = to, drop00 = drop00, \n##                 vtype = vtype, addyi = addyi, addvi = addvi)\n##         }\n##         if (is.element(measure, c(\"MD\", \"SMD\", \"SMDH\", \"ROM\", \n##             \"RPB\", \"RBIS\", \"D2OR\", \"D2ORN\", \"D2ORL\", \"CVR\", \"VR\"))) {\n##             mf.m1i <- mf[[match(\"m1i\", names(mf))]]\n##             mf.m2i <- mf[[match(\"m2i\", names(mf))]]\n##             mf.sd1i <- mf[[match(\"sd1i\", names(mf))]]\n##             mf.sd2i <- mf[[match(\"sd2i\", names(mf))]]\n##             mf.n1i <- mf[[match(\"n1i\", names(mf))]]\n##             mf.n2i <- mf[[match(\"n2i\", names(mf))]]\n##             m1i <- eval(mf.m1i, data, enclos = sys.frame(sys.parent()))\n##             m2i <- eval(mf.m2i, data, enclos = sys.frame(sys.parent()))\n##             sd1i <- eval(mf.sd1i, data, enclos = sys.frame(sys.parent()))\n##             sd2i <- eval(mf.sd2i, data, enclos = sys.frame(sys.parent()))\n##             n1i <- eval(mf.n1i, data, enclos = sys.frame(sys.parent()))\n##             n2i <- eval(mf.n2i, data, enclos = sys.frame(sys.parent()))\n##             k <- length(n1i)\n##             k.all <- k\n##             if (!is.null(subset)) {\n##                 subset <- .setnafalse(subset, k = k)\n##                 m1i <- m1i[subset]\n##                 m2i <- m2i[subset]\n##                 sd1i <- sd1i[subset]\n##                 sd2i <- sd2i[subset]\n##                 n1i <- n1i[subset]\n##                 n2i <- n2i[subset]\n##             }\n##             dat <- escalc(measure = measure, m1i = m1i, m2i = m2i, \n##                 sd1i = sd1i, sd2i = sd2i, n1i = n1i, n2i = n2i, \n##                 vtype = vtype)\n##         }\n##         if (is.element(measure, c(\"COR\", \"UCOR\", \"ZCOR\"))) {\n##             mf.ri <- mf[[match(\"ri\", names(mf))]]\n##             mf.ni <- mf[[match(\"ni\", names(mf))]]\n##             ri <- eval(mf.ri, data, enclos = sys.frame(sys.parent()))\n##             ni <- eval(mf.ni, data, enclos = sys.frame(sys.parent()))\n##             k <- length(ri)\n##             k.all <- k\n##             if (!is.null(subset)) {\n##                 subset <- .setnafalse(subset, k = k)\n##                 ri <- ri[subset]\n##                 ni <- ni[subset]\n##             }\n##             dat <- escalc(measure = measure, ri = ri, ni = ni, \n##                 vtype = vtype)\n##         }\n##         if (is.element(measure, c(\"PCOR\", \"ZPCOR\", \"SPCOR\"))) {\n##             mf.ti <- mf[[match(\"ti\", names(mf))]]\n##             mf.r2i <- mf[[match(\"r2i\", names(mf))]]\n##             mf.mi <- mf[[match(\"mi\", names(mf))]]\n##             mf.ni <- mf[[match(\"ni\", names(mf))]]\n##             ti <- eval(mf.ti, data, enclos = sys.frame(sys.parent()))\n##             r2i <- eval(mf.r2i, data, enclos = sys.frame(sys.parent()))\n##             mi <- eval(mf.mi, data, enclos = sys.frame(sys.parent()))\n##             ni <- eval(mf.ni, data, enclos = sys.frame(sys.parent()))\n##             k <- length(ti)\n##             k.all <- k\n##             if (!is.null(subset)) {\n##                 subset <- .setnafalse(subset, k = k)\n##                 ti <- ti[subset]\n##                 r2i <- r2i[subset]\n##                 mi <- mi[subset]\n##                 ni <- ni[subset]\n##             }\n##             dat <- escalc(measure = measure, ti = ti, r2i = r2i, \n##                 mi = mi, ni = ni, vtype = vtype)\n##         }\n##         if (is.element(measure, c(\"PR\", \"PLN\", \"PLO\", \"PAS\", \n##             \"PFT\"))) {\n##             mf.xi <- mf[[match(\"xi\", names(mf))]]\n##             mf.mi <- mf[[match(\"mi\", names(mf))]]\n##             mf.ni <- mf[[match(\"ni\", names(mf))]]\n##             xi <- eval(mf.xi, data, enclos = sys.frame(sys.parent()))\n##             mi <- eval(mf.mi, data, enclos = sys.frame(sys.parent()))\n##             ni <- eval(mf.ni, data, enclos = sys.frame(sys.parent()))\n##             if (is.null(mi)) \n##                 mi <- ni - xi\n##             k <- length(xi)\n##             k.all <- k\n##             if (!is.null(subset)) {\n##                 subset <- .setnafalse(subset, k = k)\n##                 xi <- xi[subset]\n##                 mi <- mi[subset]\n##             }\n##             dat <- escalc(measure = measure, xi = xi, mi = mi, \n##                 add = add, to = to, vtype = vtype, addyi = addyi, \n##                 addvi = addvi)\n##         }\n##         if (is.element(measure, c(\"IR\", \"IRLN\", \"IRS\", \"IRFT\"))) {\n##             mf.xi <- mf[[match(\"xi\", names(mf))]]\n##             mf.ti <- mf[[match(\"ti\", names(mf))]]\n##             xi <- eval(mf.xi, data, enclos = sys.frame(sys.parent()))\n##             ti <- eval(mf.ti, data, enclos = sys.frame(sys.parent()))\n##             k <- length(xi)\n##             k.all <- k\n##             if (!is.null(subset)) {\n##                 subset <- .setnafalse(subset, k = k)\n##                 xi <- xi[subset]\n##                 ti <- ti[subset]\n##             }\n##             dat <- escalc(measure = measure, xi = xi, ti = ti, \n##                 add = add, to = to, vtype = vtype, addyi = addyi, \n##                 addvi = addvi)\n##         }\n##         if (is.element(measure, c(\"MN\", \"MNLN\", \"CVLN\", \"SDLN\", \n##             \"SMD1\"))) {\n##             mf.mi <- mf[[match(\"mi\", names(mf))]]\n##             mf.sdi <- mf[[match(\"sdi\", names(mf))]]\n##             mf.ni <- mf[[match(\"ni\", names(mf))]]\n##             mi <- eval(mf.mi, data, enclos = sys.frame(sys.parent()))\n##             sdi <- eval(mf.sdi, data, enclos = sys.frame(sys.parent()))\n##             ni <- eval(mf.ni, data, enclos = sys.frame(sys.parent()))\n##             k <- length(ni)\n##             k.all <- k\n##             if (!is.null(subset)) {\n##                 subset <- .setnafalse(subset, k = k)\n##                 mi <- mi[subset]\n##                 sdi <- sdi[subset]\n##                 ni <- ni[subset]\n##             }\n##             dat <- escalc(measure = measure, mi = mi, sdi = sdi, \n##                 ni = ni, vtype = vtype)\n##         }\n##         if (is.element(measure, c(\"MC\", \"SMCC\", \"SMCR\", \"SMCRH\", \n##             \"ROMC\", \"CVRC\", \"VRC\"))) {\n##             mf.m1i <- mf[[match(\"m1i\", names(mf))]]\n##             mf.m2i <- mf[[match(\"m2i\", names(mf))]]\n##             mf.sd1i <- mf[[match(\"sd1i\", names(mf))]]\n##             mf.sd2i <- mf[[match(\"sd2i\", names(mf))]]\n##             mf.ri <- mf[[match(\"ri\", names(mf))]]\n##             mf.ni <- mf[[match(\"ni\", names(mf))]]\n##             m1i <- eval(mf.m1i, data, enclos = sys.frame(sys.parent()))\n##             m2i <- eval(mf.m2i, data, enclos = sys.frame(sys.parent()))\n##             sd1i <- eval(mf.sd1i, data, enclos = sys.frame(sys.parent()))\n##             sd2i <- eval(mf.sd2i, data, enclos = sys.frame(sys.parent()))\n##             ri <- eval(mf.ri, data, enclos = sys.frame(sys.parent()))\n##             ni <- eval(mf.ni, data, enclos = sys.frame(sys.parent()))\n##             k <- length(m1i)\n##             k.all <- k\n##             if (!is.null(subset)) {\n##                 subset <- .setnafalse(subset, k = k)\n##                 m1i <- m1i[subset]\n##                 m2i <- m2i[subset]\n##                 sd1i <- sd1i[subset]\n##                 sd2i <- sd2i[subset]\n##                 ni <- ni[subset]\n##                 ri <- ri[subset]\n##             }\n##             dat <- escalc(measure = measure, m1i = m1i, m2i = m2i, \n##                 sd1i = sd1i, sd2i = sd2i, ri = ri, ni = ni, vtype = vtype)\n##         }\n##         if (is.element(measure, c(\"ARAW\", \"AHW\", \"ABT\"))) {\n##             mf.ai <- mf[[match(\"ai\", names(mf))]]\n##             mf.mi <- mf[[match(\"mi\", names(mf))]]\n##             mf.ni <- mf[[match(\"ni\", names(mf))]]\n##             ai <- eval(mf.ai, data, enclos = sys.frame(sys.parent()))\n##             mi <- eval(mf.mi, data, enclos = sys.frame(sys.parent()))\n##             ni <- eval(mf.ni, data, enclos = sys.frame(sys.parent()))\n##             k <- length(ai)\n##             k.all <- k\n##             if (!is.null(subset)) {\n##                 subset <- .setnafalse(subset, k = k)\n##                 ai <- ai[subset]\n##                 mi <- mi[subset]\n##                 ni <- ni[subset]\n##             }\n##             dat <- escalc(measure = measure, ai = ai, mi = mi, \n##                 ni = ni, vtype = vtype)\n##         }\n##         if (is.element(measure, \"GEN\")) \n##             stop(mstyle$stop(\"Specify the desired outcome measure via the 'measure' argument.\"))\n##         yi <- dat$yi\n##         vi <- dat$vi\n##         ni <- attr(yi, \"ni\")\n##     }\n##     if (length(weights) == 1L) \n##         weights <- rep(weights, k)\n##     if (!is.null(weights) && (length(weights) != k)) \n##         stop(mstyle$stop(\"Length of 'yi' and 'weights' is not the same.\"))\n##     if (!is.null(subset)) \n##         weights <- weights[subset]\n##     if (verbose > 1) \n##         message(mstyle$message(\"Creating model matrix ...\"))\n##     if (inherits(mods, \"formula\")) {\n##         formula.mods <- mods\n##         options(na.action = \"na.pass\")\n##         mods <- model.matrix(mods, data = data)\n##         attr(mods, \"assign\") <- NULL\n##         attr(mods, \"contrasts\") <- NULL\n##         options(na.action = na.act)\n##         intercept <- FALSE\n##     }\n##     if (.is.vector(mods)) \n##         mods <- cbind(mods)\n##     if (is.data.frame(mods)) \n##         mods <- as.matrix(mods)\n##     if (is.character(mods)) \n##         stop(mstyle$stop(\"Model matrix contains character variables.\"))\n##     if (!is.null(mods) && nrow(mods) != k) \n##         stop(mstyle$stop(paste0(\"Number of rows in the model matrix (\", \n##             nrow(mods), \") does not match length of the outcome vector (\", \n##             k, \").\")))\n##     if (model == \"rma.ls\") {\n##         if (inherits(scale, \"formula\")) {\n##             formula.scale <- scale\n##             options(na.action = \"na.pass\")\n##             Z <- model.matrix(scale, data = data)\n##             colnames(Z)[grep(\"(Intercept)\", colnames(Z))] <- \"intrcpt\"\n##             attr(Z, \"assign\") <- NULL\n##             attr(Z, \"contrasts\") <- NULL\n##             options(na.action = na.act)\n##         }\n##         else {\n##             Z <- scale\n##             if (.is.vector(Z)) \n##                 Z <- cbind(Z)\n##             if (is.data.frame(Z)) \n##                 Z <- as.matrix(Z)\n##             if (is.character(Z)) \n##                 stop(mstyle$stop(\"Model matrix contains character variables.\"))\n##         }\n##         if (nrow(Z) != k) \n##             stop(mstyle$stop(paste0(\"Number of rows in the model matrix specified via the 'scale' argument (\", \n##                 nrow(Z), \") does not match length of the outcome vector (\", \n##                 k, \").\")))\n##     }\n##     else {\n##         Z <- NULL\n##     }\n##     if (verbose > 1) \n##         message(mstyle$message(\"Generating/extracting study labels ...\"))\n##     ids <- seq_len(k)\n##     if (is.null(slab)) {\n##         slab.null <- TRUE\n##         slab <- ids\n##     }\n##     else {\n##         if (anyNA(slab)) \n##             stop(mstyle$stop(\"NAs in study labels.\"))\n##         if (length(slab) != k) \n##             stop(mstyle$stop(\"Study labels not of same length as data.\"))\n##         slab.null <- FALSE\n##     }\n##     if (!is.null(subset)) {\n##         if (verbose > 1) \n##             message(mstyle$message(\"Subsetting ...\"))\n##         mods <- mods[subset, , drop = FALSE]\n##         slab <- slab[subset]\n##         ids <- ids[subset]\n##         Z <- Z[subset, , drop = FALSE]\n##     }\n##     if (anyDuplicated(slab)) \n##         slab <- .make.unique(slab)\n##     attr(yi, \"slab\") <- slab\n##     k <- length(yi)\n##     if (any(vi <= 0, na.rm = TRUE)) {\n##         allvipos <- FALSE\n##         if (!vi0) \n##             warning(mstyle$warning(\"There are outcomes with non-positive sampling variances.\"), \n##                 call. = FALSE)\n##         vi.neg <- vi < 0\n##         if (any(vi.neg, na.rm = TRUE)) {\n##             vi[vi.neg] <- 0\n##             warning(mstyle$warning(\"Negative sampling variances constrained to zero.\"), \n##                 call. = FALSE)\n##         }\n##     }\n##     else {\n##         allvipos <- TRUE\n##     }\n##     if (any(weights < 0, na.rm = TRUE)) \n##         stop(mstyle$stop(\"Negative weights not allowed.\"))\n##     if (any(is.infinite(weights))) \n##         stop(mstyle$stop(\"Infinite weights not allowed.\"))\n##     ai.f <- ai\n##     bi.f <- bi\n##     ci.f <- ci\n##     di.f <- di\n##     x1i.f <- x1i\n##     x2i.f <- x2i\n##     t1i.f <- t1i\n##     t2i.f <- t2i\n##     yi.f <- yi\n##     vi.f <- vi\n##     weights.f <- weights\n##     ni.f <- ni\n##     mods.f <- mods\n##     Z.f <- Z\n##     k.f <- k\n##     has.na <- is.na(yi) | is.na(vi) | (if (is.null(mods)) \n##         FALSE\n##     else apply(is.na(mods), 1, any)) | (if (is.null(Z)) \n##         FALSE\n##     else apply(is.na(Z), 1, any)) | (if (is.null(weights)) \n##         FALSE\n##     else is.na(weights))\n##     not.na <- !has.na\n##     if (any(has.na)) {\n##         if (verbose > 1) \n##             message(mstyle$message(\"Handling NAs ...\"))\n##         if (na.act == \"na.omit\" || na.act == \"na.exclude\" || \n##             na.act == \"na.pass\") {\n##             yi <- yi[not.na]\n##             vi <- vi[not.na]\n##             weights <- weights[not.na]\n##             ni <- ni[not.na]\n##             mods <- mods[not.na, , drop = FALSE]\n##             Z <- Z[not.na, , drop = FALSE]\n##             k <- length(yi)\n##             warning(mstyle$warning(\"Studies with NAs omitted from model fitting.\"), \n##                 call. = FALSE)\n##             attr(yi, \"measure\") <- measure\n##             attr(yi, \"ni\") <- ni\n##         }\n##         if (na.act == \"na.fail\") \n##             stop(mstyle$stop(\"Missing values in data.\"))\n##     }\n##     if (k < 1L) \n##         stop(mstyle$stop(\"Processing terminated since k = 0.\"))\n##     if (k == 1L && test != \"z\") {\n##         warning(mstyle$warning(\"Setting argument test=\\\"z\\\" since k=1.\"), \n##             call. = FALSE)\n##         test <- \"z\"\n##     }\n##     if (is.null(mods) && !intercept) {\n##         warning(mstyle$warning(\"Must either include an intercept and/or moderators in model.\\n  Coerced intercept into the model.\"), \n##             call. = FALSE)\n##         intercept <- TRUE\n##     }\n##     if (intercept) {\n##         X <- cbind(intrcpt = rep(1, k), mods)\n##         X.f <- cbind(intrcpt = rep(1, k.f), mods.f)\n##     }\n##     else {\n##         X <- mods\n##         X.f <- mods.f\n##     }\n##     tmp <- try(lm(yi ~ X - 1), silent = TRUE)\n##     if (inherits(tmp, \"lm\")) {\n##         coef.na <- is.na(coef(tmp))\n##     }\n##     else {\n##         coef.na <- rep(FALSE, NCOL(X))\n##     }\n##     if (any(coef.na)) {\n##         warning(mstyle$warning(\"Redundant predictors dropped from the model.\"), \n##             call. = FALSE)\n##         X <- X[, !coef.na, drop = FALSE]\n##         X.f <- X.f[, !coef.na, drop = FALSE]\n##     }\n##     is.int <- apply(X, 2, .is.intercept)\n##     if (any(is.int)) {\n##         int.incl <- TRUE\n##         int.indx <- which(is.int, arr.ind = TRUE)\n##         X <- cbind(intrcpt = 1, X[, -int.indx, drop = FALSE])\n##         X.f <- cbind(intrcpt = 1, X.f[, -int.indx, drop = FALSE])\n##         intercept <- TRUE\n##     }\n##     else {\n##         int.incl <- FALSE\n##     }\n##     p <- NCOL(X)\n##     if ((p == 1L) && .is.intercept(X)) {\n##         int.only <- TRUE\n##     }\n##     else {\n##         int.only <- FALSE\n##     }\n##     if (!(int.only && k == 1L)) {\n##         if (is.element(method, c(\"FE\", \"EE\", \"CE\"))) {\n##             if (p > k) \n##                 stop(mstyle$stop(\"Number of parameters to be estimated is larger than the number of observations.\"))\n##         }\n##         else {\n##             if (is.numeric(tau2)) {\n##                 if (p > k) \n##                   stop(mstyle$stop(\"Number of parameters to be estimated is larger than the number of observations.\"))\n##             }\n##             else {\n##                 if ((p + 1) > k) \n##                   stop(mstyle$stop(\"Number of parameters to be estimated is larger than the number of observations.\"))\n##             }\n##         }\n##     }\n##     btt <- .set.btt(btt, p, int.incl, colnames(X))\n##     m <- length(btt)\n##     con <- list(verbose = FALSE, tau2.init = NULL, tau2.min = 0, \n##         tau2.max = 100, threshold = 10^-5, tol = .Machine$double.eps^0.25, \n##         ll0check = TRUE, maxiter = 100, stepadj = 1, REMLf = TRUE, \n##         evtol = 1e-07, alpha.init = NULL, optimizer = \"nlminb\", \n##         optmethod = \"BFGS\", parallel = list(), cl = NULL, ncpus = 1L, \n##         hessianCtrl = list(r = 8), scaleZ = TRUE)\n##     con.pos <- pmatch(names(control), names(con))\n##     con[c(na.omit(con.pos))] <- control[!is.na(con.pos)]\n##     if (verbose) \n##         con$verbose <- verbose\n##     verbose <- con$verbose\n##     if (con$tau2.min < 0 && (-con$tau2.min > min(vi))) {\n##         con$tau2.min <- -min(vi)\n##         warning(mstyle$warning(paste0(\"Value of 'tau2.min' constrained to -min(vi) = \", \n##             .fcf(-min(vi), digits[[\"est\"]]), \".\")), call. = FALSE)\n##     }\n##     conv <- 1\n##     change <- con$threshold + 1\n##     if (any(eigen(crossprod(X), symmetric = TRUE, only.values = TRUE)$values <= \n##         con$evtol)) \n##         stop(mstyle$stop(\"Model matrix not of full rank. Cannot fit model.\"))\n##     vimaxmin <- max(vi)/min(vi)\n##     if (!is.nan(vimaxmin) && !is.infinite(vimaxmin) && vimaxmin >= \n##         1/con$evtol) \n##         warning(mstyle$warning(\"Ratio of largest to smallest sampling variance extremely large. May not be able to obtain stable results.\"), \n##             call. = FALSE)\n##     iter <- 0\n##     se.tau2 <- I2 <- H2 <- QE <- QEp <- NA\n##     s2w <- 1\n##     level <- ifelse(level == 0, 1, ifelse(level >= 1, (100 - \n##         level)/100, ifelse(level > 0.5, 1 - level, level)))\n##     Y <- as.matrix(yi)\n##     if (model == \"rma.uni\") {\n##         if (is.numeric(tau2) && !is.element(method, c(\"FE\", \"EE\", \n##             \"CE\"))) {\n##             tau2.fix <- TRUE\n##             tau2.val <- tau2\n##         }\n##         else {\n##             tau2.fix <- FALSE\n##             tau2.val <- NA\n##         }\n##         if (verbose > 1 && !tau2.fix && !is.element(method, c(\"FE\", \n##             \"EE\", \"CE\"))) \n##             message(mstyle$message(\"Estimating tau^2 value ...\\n\"))\n##         if (k == 1L) {\n##             method.sav <- method\n##             method = \"k1\"\n##             if (!tau2.fix) \n##                 tau2 <- 0\n##         }\n##         if (is.element(method, c(\"HS\", \"HSk\"))) {\n##             if (!allvipos) \n##                 stop(mstyle$stop(method, \" estimator cannot be used when there are non-positive sampling variances in the data.\"))\n##             wi <- 1/vi\n##             W <- diag(wi, nrow = k, ncol = k)\n##             stXWX <- .invcalc(X = X, W = W, k = k)\n##             P <- W - W %*% X %*% stXWX %*% crossprod(X, W)\n##             RSS <- crossprod(Y, P) %*% Y\n##             if (method == \"HS\") {\n##                 tau2 <- ifelse(tau2.fix, tau2.val, (RSS - k)/sum(wi))\n##             }\n##             else {\n##                 tau2 <- ifelse(tau2.fix, tau2.val, (k/(k - p) * \n##                   RSS - k)/sum(wi))\n##             }\n##         }\n##         if (is.element(method, c(\"HE\", \"ML\", \"REML\", \"EB\"))) {\n##             stXX <- .invcalc(X = X, W = diag(k), k = k)\n##             P <- diag(k) - X %*% tcrossprod(stXX, X)\n##             RSS <- crossprod(Y, P) %*% Y\n##             V <- diag(vi, nrow = k, ncol = k)\n##             PV <- P %*% V\n##             trPV <- .tr(PV)\n##             tau2 <- ifelse(tau2.fix, tau2.val, (RSS - trPV)/(k - \n##                 p))\n##         }\n##         if (method == \"DL\") {\n##             if (!allvipos) \n##                 stop(mstyle$stop(\"DL estimator cannot be used when there are non-positive sampling variances in the data.\"))\n##             wi <- 1/vi\n##             W <- diag(wi, nrow = k, ncol = k)\n##             stXWX <- .invcalc(X = X, W = W, k = k)\n##             P <- W - W %*% X %*% stXWX %*% crossprod(X, W)\n##             RSS <- crossprod(Y, P) %*% Y\n##             trP <- .tr(P)\n##             tau2 <- ifelse(tau2.fix, tau2.val, (RSS - (k - p))/trP)\n##         }\n##         if (method == \"DLIT\") {\n##             if (is.null(con$tau2.init)) {\n##                 tau2 <- 0\n##             }\n##             else {\n##                 tau2 <- con$tau2.init\n##             }\n##             while (change > con$threshold) {\n##                 if (verbose) \n##                   cat(mstyle$verbose(paste(\"Iteration\", iter, \n##                     \"\\ttau^2 =\", .fcf(tau2, digits[[\"var\"]]), \n##                     \"\\n\")))\n##                 iter <- iter + 1\n##                 old2 <- tau2\n##                 wi <- 1/(vi + tau2)\n##                 if (any(tau2 + vi < 0)) \n##                   stop(mstyle$stop(\"Some marginal variances are negative.\"))\n##                 if (any(is.infinite(wi))) \n##                   stop(mstyle$stop(\"Division by zero when computing the inverse variance weights.\"))\n##                 W <- diag(wi, nrow = k, ncol = k)\n##                 stXWX <- .invcalc(X = X, W = W, k = k)\n##                 P <- W - W %*% X %*% stXWX %*% crossprod(X, W)\n##                 RSS <- crossprod(Y, P) %*% Y\n##                 trP <- .tr(P)\n##                 tau2 <- ifelse(tau2.fix, tau2.val, (RSS - (k - \n##                   p))/trP)\n##                 tau2[tau2 < con$tau2.min] <- con$tau2.min\n##                 change <- abs(old2 - tau2)\n##                 if (iter > con$maxiter) {\n##                   conv <- 0\n##                   break\n##                 }\n##             }\n##             if (conv == 0L) \n##                 stop(mstyle$stop(\"Algorithm did not converge.\"))\n##         }\n##         if (method == \"GENQ\") {\n##             if (is.null(weights)) \n##                 stop(mstyle$stop(\"Must specify 'weights' when method='GENQ'.\"))\n##             A <- diag(weights, nrow = k, ncol = k)\n##             stXAX <- .invcalc(X = X, W = A, k = k)\n##             P <- A - A %*% X %*% stXAX %*% t(X) %*% A\n##             V <- diag(vi, nrow = k, ncol = k)\n##             PV <- P %*% V\n##             trP <- .tr(P)\n##             trPV <- .tr(PV)\n##             RSS <- crossprod(Y, P) %*% Y\n##             tau2 <- ifelse(tau2.fix, tau2.val, (RSS - trPV)/trP)\n##         }\n##         if (method == \"GENQM\") {\n##             if (is.null(weights)) \n##                 stop(mstyle$stop(\"Must specify 'weights' when method='GENQM'.\"))\n##             A <- diag(weights, nrow = k, ncol = k)\n##             stXAX <- .invcalc(X = X, W = A, k = k)\n##             P <- A - A %*% X %*% stXAX %*% t(X) %*% A\n##             V <- diag(vi, nrow = k, ncol = k)\n##             PV <- P %*% V\n##             trP <- .tr(P)\n##             if (!tau2.fix) {\n##                 RSS <- crossprod(Y, P) %*% Y\n##                 if (.GENQ.func(con$tau2.min, P = P, vi = vi, \n##                   Q = RSS, level = 0, k = k, p = p, getlower = TRUE) > \n##                   0.5) {\n##                   tau2 <- con$tau2.min\n##                 }\n##                 else {\n##                   if (.GENQ.func(con$tau2.max, P = P, vi = vi, \n##                     Q = RSS, level = 0, k = k, p = p, getlower = TRUE) < \n##                     0.5) {\n##                     stop(mstyle$stop(\"Value of 'tau2.max' too low. Try increasing 'tau2.max' or switch to another 'method'.\"))\n##                   }\n##                   else {\n##                     tau2 <- try(uniroot(.GENQ.func, interval = c(con$tau2.min, \n##                       con$tau2.max), tol = con$tol, maxiter = con$maxiter, \n##                       P = P, vi = vi, Q = RSS, level = 0.5, k = k, \n##                       p = p, getlower = FALSE, verbose = verbose, \n##                       digits = digits, extendInt = \"no\")$root, \n##                       silent = TRUE)\n##                     if (inherits(tau2, \"try-error\")) \n##                       stop(mstyle$stop(\"Error in iterative search for tau2 using uniroot().\"))\n##                   }\n##                 }\n##             }\n##             else {\n##                 tau2 <- tau2.val\n##             }\n##             wi <- 1/(vi + tau2)\n##         }\n##         if (method == \"SJ\") {\n##             if (is.null(con$tau2.init)) {\n##                 tau2.0 <- c(var(yi) * (k - 1)/k)\n##             }\n##             else {\n##                 tau2.0 <- con$tau2.init\n##             }\n##             wi <- 1/(vi + tau2.0)\n##             W <- diag(wi, nrow = k, ncol = k)\n##             stXWX <- .invcalc(X = X, W = W, k = k)\n##             P <- W - W %*% X %*% stXWX %*% crossprod(X, W)\n##             RSS <- crossprod(Y, P) %*% Y\n##             V <- diag(vi, nrow = k, ncol = k)\n##             PV <- P %*% V\n##             tau2 <- ifelse(tau2.fix, tau2.val, tau2.0 * RSS/(k - \n##                 p))\n##         }\n##         if (method == \"SJIT\") {\n##             if (is.null(con$tau2.init)) {\n##                 tau2 <- var(yi) * (k - 1)/k\n##             }\n##             else {\n##                 tau2 <- con$tau2.init\n##             }\n##             tau2.0 <- tau2\n##             while (change > con$threshold) {\n##                 if (verbose) \n##                   cat(mstyle$verbose(paste(\"Iteration\", iter, \n##                     \"\\ttau^2 =\", .fcf(tau2, digits[[\"var\"]]), \n##                     \"\\n\")))\n##                 iter <- iter + 1\n##                 old2 <- tau2\n##                 wi <- 1/(vi + tau2)\n##                 W <- diag(wi, nrow = k, ncol = k)\n##                 stXWX <- .invcalc(X = X, W = W, k = k)\n##                 P <- W - W %*% X %*% stXWX %*% crossprod(X, W)\n##                 RSS <- crossprod(Y, P) %*% Y\n##                 V <- diag(vi, nrow = k, ncol = k)\n##                 PV <- P %*% V\n##                 tau2 <- ifelse(tau2.fix, tau2.val, tau2 * RSS/(k - \n##                   p))\n##                 change <- abs(old2 - tau2)\n##                 if (iter > con$maxiter) {\n##                   conv <- 0\n##                   break\n##                 }\n##             }\n##             if (conv == 0L) \n##                 stop(mstyle$stop(\"Algorithm did not converge.\"))\n##         }\n##         if (method == \"PM\") {\n##             if (!allvipos) \n##                 stop(mstyle$stop(\"PM estimator cannot be used when there are non-positive sampling variances in the data.\"))\n##             if (!tau2.fix) {\n##                 if (.QE.func(con$tau2.min, Y = Y, vi = vi, X = X, \n##                   k = k, objective = 0) < k - p) {\n##                   tau2 <- con$tau2.min\n##                 }\n##                 else {\n##                   if (.QE.func(con$tau2.max, Y = Y, vi = vi, \n##                     X = X, k = k, objective = 0) > k - p) {\n##                     stop(mstyle$stop(\"Value of 'tau2.max' too low. Try increasing 'tau2.max' or switch to another 'method'.\"))\n##                   }\n##                   else {\n##                     tau2 <- try(uniroot(.QE.func, interval = c(con$tau2.min, \n##                       con$tau2.max), tol = con$tol, maxiter = con$maxiter, \n##                       Y = Y, vi = vi, X = X, k = k, objective = k - \n##                         p, verbose = verbose, digits = digits, \n##                       extendInt = \"no\")$root, silent = TRUE)\n##                     if (inherits(tau2, \"try-error\")) \n##                       stop(mstyle$stop(\"Error in iterative search for tau2 using uniroot().\"))\n##                   }\n##                 }\n##             }\n##             else {\n##                 tau2 <- tau2.val\n##             }\n##             wi <- 1/(vi + tau2)\n##         }\n##         if (method == \"PMM\") {\n##             if (!allvipos) \n##                 stop(mstyle$stop(\"PMM estimator cannot be used when there are non-positive sampling variances in the data.\"))\n##             if (!tau2.fix) {\n##                 if (.QE.func(con$tau2.min, Y = Y, vi = vi, X = X, \n##                   k = k, objective = 0) < qchisq(0.5, df = k - \n##                   p)) {\n##                   tau2 <- con$tau2.min\n##                 }\n##                 else {\n##                   if (.QE.func(con$tau2.max, Y = Y, vi = vi, \n##                     X = X, k = k, objective = 0) > qchisq(0.5, \n##                     df = k - p)) {\n##                     stop(mstyle$stop(\"Value of 'tau2.max' too low. Try increasing 'tau2.max' or switch to another 'method'.\"))\n##                   }\n##                   else {\n##                     tau2 <- try(uniroot(.QE.func, interval = c(con$tau2.min, \n##                       con$tau2.max), tol = con$tol, maxiter = con$maxiter, \n##                       Y = Y, vi = vi, X = X, k = k, objective = qchisq(0.5, \n##                         df = k - p), verbose = verbose, digits = digits, \n##                       extendInt = \"no\")$root, silent = TRUE)\n##                     if (inherits(tau2, \"try-error\")) \n##                       stop(mstyle$stop(\"Error in iterative search for tau2. Try increasing 'tau2.max' or switch to another 'method'.\"))\n##                   }\n##                 }\n##             }\n##             else {\n##                 tau2 <- tau2.val\n##             }\n##             wi <- 1/(vi + tau2)\n##         }\n##         if (is.element(method, c(\"ML\", \"REML\", \"EB\"))) {\n##             if (is.null(con$tau2.init)) {\n##                 tau2 <- max(0, tau2, con$tau2.min)\n##             }\n##             else {\n##                 tau2 <- con$tau2.init\n##             }\n##             while (change > con$threshold) {\n##                 if (verbose) \n##                   cat(mstyle$verbose(paste(mstyle$verbose(paste(\"Iteration\", \n##                     iter, \"\\ttau^2 =\", .fcf(tau2, digits[[\"var\"]]), \n##                     \"\\n\")))))\n##                 iter <- iter + 1\n##                 old2 <- tau2\n##                 wi <- 1/(vi + tau2)\n##                 if (any(tau2 + vi < 0)) \n##                   stop(mstyle$stop(\"Some marginal variances are negative.\"))\n##                 if (any(is.infinite(wi))) \n##                   stop(mstyle$stop(\"Division by zero when computing the inverse variance weights.\"))\n##                 W <- diag(wi, nrow = k, ncol = k)\n##                 stXWX <- .invcalc(X = X, W = W, k = k)\n##                 P <- W - W %*% X %*% stXWX %*% crossprod(X, W)\n##                 if (method == \"ML\") {\n##                   PP <- P %*% P\n##                   adj <- (crossprod(Y, PP) %*% Y - sum(wi))/sum(wi^2)\n##                 }\n##                 if (method == \"REML\") {\n##                   PP <- P %*% P\n##                   adj <- (crossprod(Y, PP) %*% Y - .tr(P))/.tr(PP)\n##                 }\n##                 if (method == \"EB\") {\n##                   adj <- (crossprod(Y, P) %*% Y * k/(k - p) - \n##                     k)/sum(wi)\n##                 }\n##                 adj <- adj * con$stepadj\n##                 while (tau2 + adj < con$tau2.min) adj <- adj/2\n##                 tau2 <- ifelse(tau2.fix, tau2.val, tau2 + adj)\n##                 change <- abs(old2 - tau2)\n##                 if (iter > con$maxiter) {\n##                   conv <- 0\n##                   break\n##                 }\n##             }\n##             if (conv == 0L) \n##                 stop(mstyle$stop(\"Fisher scoring algorithm did not converge. See 'help(rma)' for possible remedies.\"))\n##             if (is.element(method, c(\"ML\", \"REML\")) && con$ll0check && \n##                 allvipos && !tau2.fix) {\n##                 wi <- 1/vi\n##                 W <- diag(wi, nrow = k, ncol = k)\n##                 stXWX <- .invcalc(X = X, W = W, k = k)\n##                 beta <- stXWX %*% crossprod(X, W) %*% Y\n##                 RSS <- sum(wi * (yi - X %*% beta)^2)\n##                 if (method == \"ML\") \n##                   ll0 <- -1/2 * (k) * log(2 * base::pi) - 1/2 * \n##                     sum(log(vi)) - 1/2 * RSS\n##                 if (method == \"REML\") \n##                   ll0 <- -1/2 * (k - p) * log(2 * base::pi) - \n##                     1/2 * sum(log(vi)) - 1/2 * determinant(crossprod(X, \n##                     W) %*% X, logarithm = TRUE)$modulus - 1/2 * \n##                     RSS\n##                 wi <- 1/(vi + tau2)\n##                 if (any(tau2 + vi < 0)) \n##                   stop(mstyle$stop(\"Some marginal variances are negative.\"))\n##                 if (any(is.infinite(wi))) \n##                   stop(mstyle$stop(\"Division by zero when computing the inverse variance weights.\"))\n##                 W <- diag(wi, nrow = k, ncol = k)\n##                 stXWX <- .invcalc(X = X, W = W, k = k)\n##                 beta <- stXWX %*% crossprod(X, W) %*% Y\n##                 RSS <- sum(wi * (yi - X %*% beta)^2)\n##                 if (method == \"ML\") \n##                   ll <- -1/2 * (k) * log(2 * base::pi) - 1/2 * \n##                     sum(log(vi + tau2)) - 1/2 * RSS\n##                 if (method == \"REML\") \n##                   ll <- -1/2 * (k - p) * log(2 * base::pi) - \n##                     1/2 * sum(log(vi + tau2)) - 1/2 * determinant(crossprod(X, \n##                     W) %*% X, logarithm = TRUE)$modulus - 1/2 * \n##                     RSS\n##                 if (ll0 - ll > con$tol && tau2 > con$threshold) {\n##                   warning(mstyle$warning(\"Fisher scoring algorithm may have gotten stuck at a local maximum.\\n  Setting tau^2 = 0. Check the profile likelihood plot with profile().\"), \n##                     call. = FALSE)\n##                   tau2 <- 0\n##                 }\n##             }\n##             wi <- 1/(vi + tau2)\n##             if (any(tau2 + vi < 0)) \n##                 stop(mstyle$stop(\"Some marginal variances are negative.\"))\n##             if (any(is.infinite(wi))) \n##                 stop(mstyle$stop(\"Division by zero when computing the inverse variance weights.\"))\n##             W <- diag(wi, nrow = k, ncol = k)\n##             stXWX <- .invcalc(X = X, W = W, k = k)\n##             P <- W - W %*% X %*% stXWX %*% crossprod(X, W)\n##         }\n##         tau2 <- max(con$tau2.min, c(tau2))\n##         if (!is.na(tau2) && any(tau2 + vi < 0)) \n##             stop(mstyle$stop(\"Some marginal variances are negative.\"))\n##         if (verbose && is.element(method, c(\"ML\", \"REML\", \"EB\"))) {\n##             cat(mstyle$verbose(paste(\"Iteration\", iter, \"\\ttau^2 =\", \n##                 .fcf(tau2, digits[[\"var\"]]), \"\\n\")))\n##             cat(mstyle$verbose(paste(\"Fisher scoring algorithm converged after\", \n##                 iter, \"iterations.\\n\")))\n##         }\n##         if (method == \"HS\") \n##             se.tau2 <- sqrt(1/sum(wi)^2 * (2 * (k - p) + 4 * \n##                 max(tau2, 0) * .tr(P) + 2 * max(tau2, 0)^2 * \n##                 sum(P * P)))\n##         if (method == \"HSk\") \n##             se.tau2 <- k/(k - p) * sqrt(1/sum(wi)^2 * (2 * (k - \n##                 p) + 4 * max(tau2, 0) * .tr(P) + 2 * max(tau2, \n##                 0)^2 * sum(P * P)))\n##         if (method == \"HE\") \n##             se.tau2 <- sqrt(1/(k - p)^2 * (2 * sum(PV * t(PV)) + \n##                 4 * max(tau2, 0) * trPV + 2 * max(tau2, 0)^2 * \n##                 (k - p)))\n##         if (method == \"DL\" || method == \"DLIT\") \n##             se.tau2 <- sqrt(1/trP^2 * (2 * (k - p) + 4 * max(tau2, \n##                 0) * trP + 2 * max(tau2, 0)^2 * sum(P * P)))\n##         if (method == \"GENQ\" || method == \"GENQM\") \n##             se.tau2 <- sqrt(1/trP^2 * (2 * sum(PV * t(PV)) + \n##                 4 * max(tau2, 0) * sum(PV * P) + 2 * max(tau2, \n##                 0)^2 * sum(P * P)))\n##         if (method == \"SJ\") \n##             se.tau2 <- sqrt(tau2.0^2/(k - p)^2 * (2 * sum(PV * \n##                 t(PV)) + 4 * max(tau2, 0) * sum(PV * P) + 2 * \n##                 max(tau2, 0)^2 * sum(P * P)))\n##         if (method == \"ML\") \n##             se.tau2 <- sqrt(2/sum(wi^2))\n##         if (method == \"REML\") \n##             se.tau2 <- sqrt(2/sum(P * P))\n##         if (method == \"EB\" || method == \"PM\" || method == \"PMM\" || \n##             method == \"SJIT\") {\n##             se.tau2 <- sqrt(2 * k^2/(k - p)/sum(wi)^2)\n##         }\n##         if (k == 1L) \n##             method <- method.sav\n##     }\n##     if (model == \"rma.ls\") {\n##         if (!is.element(method, c(\"ML\", \"REML\"))) \n##             stop(mstyle$stop(\"Location-scale models can only be fitted with ML or REML estimation.\"))\n##         tau2.fix <- FALSE\n##         if (is.numeric(tau2)) \n##             warning(mstyle$warning(\"Argument 'tau2' ignored for location-scale models.\"), \n##                 call. = FALSE)\n##         optimizer <- match.arg(con$optimizer, c(\"optim\", \"nlminb\", \n##             \"uobyqa\", \"newuoa\", \"bobyqa\", \"nloptr\", \"nlm\", \"hjk\", \n##             \"nmk\", \"mads\", \"ucminf\", \"optimParallel\", \"constrOptim\"))\n##         optmethod <- match.arg(con$optmethod, c(\"Nelder-Mead\", \n##             \"BFGS\", \"CG\", \"L-BFGS-B\", \"SANN\", \"Brent\"))\n##         parallel <- con$parallel\n##         cl <- con$cl\n##         ncpus <- con$ncpus\n##         optcontrol <- control[is.na(con.pos)]\n##         if (length(optcontrol) == 0L) \n##             optcontrol <- list()\n##         if (ncpus > 1L) \n##             optimizer <- \"optimParallel\"\n##         if (link == \"identity\") \n##             optimizer <- \"constrOptim\"\n##         if (link == \"log\" && optimizer == \"constrOptim\") \n##             stop(mstyle$stop(\"Cannot use 'constrOptim' optimizer when using a log link.\"))\n##         reml <- ifelse(method == \"REML\", TRUE, FALSE)\n##         if (optimizer == \"nloptr\" && !is.element(\"algorithm\", \n##             names(optcontrol))) \n##             optcontrol$algorithm <- \"NLOPT_LN_BOBYQA\"\n##         if (optimizer == \"nloptr\" && !is.element(\"ftol_rel\", \n##             names(optcontrol))) \n##             optcontrol$ftol_rel <- 1e-08\n##         if (optimizer == \"mads\" && !is.element(\"trace\", names(optcontrol))) \n##             optcontrol$trace <- FALSE\n##         if (optimizer == \"mads\" && !is.element(\"tol\", names(optcontrol))) \n##             optcontrol$tol <- 1e-06\n##         if (is.element(optimizer, c(\"uobyqa\", \"newuoa\", \"bobyqa\"))) {\n##             if (!requireNamespace(\"minqa\", quietly = TRUE)) \n##                 stop(mstyle$stop(\"Please install the 'minqa' package to use this optimizer.\"))\n##         }\n##         if (optimizer == \"nloptr\") {\n##             if (!requireNamespace(\"nloptr\", quietly = TRUE)) \n##                 stop(mstyle$stop(\"Please install the 'nloptr' package to use this optimizer.\"))\n##         }\n##         if (is.element(optimizer, c(\"hjk\", \"nmk\", \"mads\"))) {\n##             if (!requireNamespace(\"dfoptim\", quietly = TRUE)) \n##                 stop(mstyle$stop(\"Please install the 'dfoptim' package to use this optimizer.\"))\n##         }\n##         if (optimizer == \"ucminf\") {\n##             if (!requireNamespace(\"ucminf\", quietly = TRUE)) \n##                 stop(mstyle$stop(\"Please install the 'ucminf' package to use this optimizer.\"))\n##         }\n##         if (optimizer == \"optimParallel\") {\n##             if (!requireNamespace(\"optimParallel\", quietly = TRUE)) \n##                 stop(mstyle$stop(\"Please install the 'optimParallel' package to use this optimizer.\"))\n##         }\n##         if (!isTRUE(ddd$skiphes) && !requireNamespace(\"numDeriv\", \n##             quietly = TRUE)) \n##             stop(mstyle$stop(\"Please install the 'numDeriv' package to compute the Hessian.\"))\n##         tmp <- try(lm(yi ~ Z - 1), silent = TRUE)\n##         if (inherits(tmp, \"lm\")) {\n##             coef.na.Z <- is.na(coef(tmp))\n##         }\n##         else {\n##             coef.na.Z <- rep(FALSE, NCOL(Z))\n##         }\n##         if (any(coef.na.Z)) {\n##             warning(mstyle$warning(\"Redundant predictors dropped from the scale model.\"), \n##                 call. = FALSE)\n##             Z <- Z[, !coef.na.Z, drop = FALSE]\n##             Z.f <- Z.f[, !coef.na.Z, drop = FALSE]\n##         }\n##         is.int <- apply(Z, 2, .is.intercept)\n##         if (any(is.int)) {\n##             Z.int.incl <- TRUE\n##             int.indx <- which(is.int, arr.ind = TRUE)\n##             Z <- cbind(intrcpt = 1, Z[, -int.indx, drop = FALSE])\n##             Z.f <- cbind(intrcpt = 1, Z.f[, -int.indx, drop = FALSE])\n##             Z.intercept <- TRUE\n##         }\n##         else {\n##             Z.int.incl <- FALSE\n##         }\n##         q <- NCOL(Z)\n##         if (any(eigen(crossprod(Z), symmetric = TRUE, only.values = TRUE)$values <= \n##             con$evtol)) \n##             stop(mstyle$stop(\"Model matrix for scale part of the model not of full rank. Cannot fit model.\"))\n##         is.int <- apply(Z, 2, .is.intercept)\n##         if ((q == 1L) && is.int) {\n##             Z.int.only <- TRUE\n##         }\n##         else {\n##             Z.int.only <- FALSE\n##         }\n##         if (missing(alpha) || is.null(alpha) || all(is.na(alpha))) {\n##             alpha <- rep(NA, q)\n##         }\n##         else {\n##             if (length(alpha) == 1L) \n##                 alpha <- rep(alpha, q)\n##             if (length(alpha) != q) \n##                 stop(mstyle$stop(paste0(\"Length of 'alpha' argument (\", \n##                   length(alpha), \") does not match actual number of parameters (\", \n##                   q, \").\")))\n##         }\n##         if (!Z.int.only && Z.int.incl && con$scaleZ && is.na(alpha[1])) {\n##             Zsave <- Z\n##             meanZ <- colMeans(Z[, 2:q, drop = FALSE])\n##             sdZ <- apply(Z[, 2:q, drop = FALSE], 2, sd)\n##             is.d <- apply(Z, 2, .is.dummy)\n##             mZ <- rbind(c(intrcpt = 1, -1 * ifelse(is.d[-1], \n##                 0, meanZ/sdZ)), cbind(0, diag(ifelse(is.d[-1], \n##                 1, 1/sdZ), nrow = length(is.d) - 1, ncol = length(is.d) - \n##                 1)))\n##             imZ <- try(suppressWarnings(solve(mZ)), silent = TRUE)\n##             Z[, !is.d] <- apply(Z[, !is.d, drop = FALSE], 2, \n##                 scale)\n##             if (any(!is.na(alpha))) {\n##                 if (inherits(imZ, \"try-error\")) \n##                   stop(mstyle$stop(\"Unable to rescale starting values for the scale parameters.\"))\n##                 alpha <- diag(imZ) * alpha\n##             }\n##         }\n##         else {\n##             mZ <- NULL\n##         }\n##         if (k == 1L && Z.int.only) {\n##             if (link == \"log\") \n##                 con$alpha.init <- -10000\n##             if (link == \"identity\") \n##                 con$alpha.init <- 1e-05\n##         }\n##         if (verbose > 1) \n##             message(mstyle$message(\"Extracting/computing initial values ...\"))\n##         if (is.null(con$alpha.init)) {\n##             fit <- suppressWarnings(rma.uni(yi, vi, mods = X, \n##                 intercept = FALSE, method = \"HE\", skipr2 = TRUE))\n##             tmp <- rstandard(fit)\n##             if (link == \"log\") {\n##                 tmp <- suppressWarnings(rma.uni(log(tmp$resid^2), \n##                   4/tmp$resid^2 * tmp$se^2, mods = Z, intercept = FALSE, \n##                   method = \"FE\"))\n##                 alpha.init <- coef(tmp)\n##             }\n##             if (link == \"identity\") {\n##                 tmp <- suppressWarnings(rma.uni(tmp$resid^2, \n##                   tmp$se^2, mods = Z, intercept = FALSE, method = \"FE\"))\n##                 alpha.init <- coef(tmp)\n##                 if (any(Z %*% alpha.init < 0)) \n##                   alpha.init <- ifelse(is.int, fit$tau2 + 0.01, \n##                     0)\n##                 if (any(Z %*% alpha.init < 0)) \n##                   stop(mstyle$stop(\"Unable to find suitable starting values for the scale parameters.\"))\n##             }\n##         }\n##         else {\n##             alpha.init <- con$alpha.init\n##             if (!Z.int.only && Z.int.incl && con$scaleZ && is.na(alpha[1])) {\n##                 if (inherits(imZ, \"try-error\")) \n##                   stop(mstyle$stop(\"Unable to rescale starting values for the scale parameters.\"))\n##                 alpha.init <- c(imZ %*% cbind(alpha.init))\n##             }\n##             if (link == \"identity\" && any(Z %*% alpha.init < \n##                 0)) \n##                 stop(mstyle$stop(\"Starting values for the scale parameters lead to one or more negative tau^2 values.\"))\n##         }\n##         if (length(alpha.init) != q) \n##             stop(mstyle$stop(paste0(\"Length of 'alpha.init' argument (\", \n##                 length(alpha.init), \") does not match actual number of parameters (\", \n##                 q, \").\")))\n##         if (anyNA(alpha.init)) \n##             stop(mstyle$stop(\"No missing values allowed in 'alpha.init'.\"))\n##         if (verbose > 1) \n##             message(mstyle$message(\"Estimating scale parameters ...\\n\"))\n##         if (is.element(optimizer, c(\"optim\", \"constrOptim\"))) {\n##             par.arg <- \"par\"\n##             ctrl.arg <- \", control=optcontrol\"\n##         }\n##         if (optimizer == \"nlminb\") {\n##             par.arg <- \"start\"\n##             ctrl.arg <- \", control=optcontrol\"\n##         }\n##         if (is.element(optimizer, c(\"uobyqa\", \"newuoa\", \"bobyqa\"))) {\n##             par.arg <- \"par\"\n##             optimizer <- paste0(\"minqa::\", optimizer)\n##             ctrl.arg <- \", control=optcontrol\"\n##         }\n##         if (optimizer == \"nloptr\") {\n##             par.arg <- \"x0\"\n##             optimizer <- paste0(\"nloptr::nloptr\")\n##             ctrl.arg <- \", opts=optcontrol\"\n##         }\n##         if (optimizer == \"nlm\") {\n##             par.arg <- \"p\"\n##             ctrl.arg <- paste(names(optcontrol), unlist(optcontrol), \n##                 sep = \"=\", collapse = \", \")\n##             if (nchar(ctrl.arg) != 0L) \n##                 ctrl.arg <- paste0(\", \", ctrl.arg)\n##         }\n##         if (is.element(optimizer, c(\"hjk\", \"nmk\", \"mads\"))) {\n##             par.arg <- \"par\"\n##             optimizer <- paste0(\"dfoptim::\", optimizer)\n##             ctrl.arg <- \", control=optcontrol\"\n##         }\n##         if (optimizer == \"ucminf\") {\n##             par.arg <- \"par\"\n##             optimizer <- paste0(\"ucminf::ucminf\")\n##             ctrl.arg <- \", control=optcontrol\"\n##         }\n##         if (optimizer == \"optimParallel\") {\n##             par.arg <- \"par\"\n##             optimizer <- paste0(\"optimParallel::optimParallel\")\n##             ctrl.arg <- \", control=optcontrol, parallel=parallel\"\n##             parallel$cl <- NULL\n##             if (is.null(cl)) {\n##                 ncpus <- as.integer(ncpus)\n##                 if (ncpus < 1L) \n##                   stop(mstyle$stop(\"Control argument 'ncpus' must be >= 1.\"))\n##                 cl <- parallel::makePSOCKcluster(ncpus)\n##                 on.exit(parallel::stopCluster(cl), add = TRUE)\n##             }\n##             else {\n##                 if (!inherits(cl, \"SOCKcluster\")) \n##                   stop(mstyle$stop(\"Specified cluster is not of class 'SOCKcluster'.\"))\n##             }\n##             parallel$cl <- cl\n##             if (is.null(parallel$forward)) \n##                 parallel$forward <- FALSE\n##             if (is.null(parallel$loginfo)) {\n##                 if (verbose) {\n##                   parallel$loginfo <- TRUE\n##                 }\n##                 else {\n##                   parallel$loginfo <- FALSE\n##                 }\n##             }\n##         }\n##         if (link == \"log\") {\n##             optcall <- paste(optimizer, \"(\", par.arg, \"=alpha.init, .ll.rma.ls, \", \n##                 ifelse(optimizer == \"optim\", \"method=optmethod, \", \n##                   \"\"), \"yi=yi, vi=vi, X=X, Z=Z, reml=reml, k=k, pX=p, alpha.val=alpha, verbose=verbose, digits=digits,\\n                                                       #hessian=TRUE,\\n                                                       REMLf=con$REMLf, link=link, mZ=mZ\", \n##                 ctrl.arg, \")\\n\", sep = \"\")\n##         }\n##         if (link == \"identity\") {\n##             optcall <- paste0(\"constrOptim(theta=alpha.init, f=.ll.rma.ls, grad=NULL, ui=Z, ci=rep(0,k),\\n                                yi=yi, vi=vi, X=X, Z=Z, reml=reml, k=k, pX=p, alpha.val=alpha, verbose=verbose, digits=digits,\\n                                REMLf=con$REMLf, link=link, mZ=mZ\", \n##                 ctrl.arg, \")\\n\")\n##         }\n##         if (verbose) {\n##             opt.res <- try(eval(parse(text = optcall)), silent = !verbose)\n##         }\n##         else {\n##             opt.res <- try(suppressWarnings(eval(parse(text = optcall))), \n##                 silent = !verbose)\n##         }\n##         if (optimizer == \"optimParallel::optimParallel\" && verbose) {\n##             tmp <- capture.output(print(opt.res$loginfo))\n##             .print.output(tmp, mstyle$verbose)\n##         }\n##         if (inherits(opt.res, \"try-error\")) \n##             stop(mstyle$stop(\"Error during the optimization. Use verbose=TRUE and see help(rma) for more details on the optimization routines.\"))\n##         if (is.element(optimizer, c(\"optim\", \"constrOptim\", \"nlminb\", \n##             \"dfoptim::hjk\", \"dfoptim::nmk\", \"optimParallel::optimParallel\")) && \n##             opt.res$convergence != 0) \n##             stop(mstyle$stop(paste0(\"Optimizer (\", optimizer, \n##                 \") did not achieve convergence (convergence = \", \n##                 opt.res$convergence, \").\")))\n##         if (is.element(optimizer, c(\"dfoptim::mads\")) && opt.res$convergence > \n##             optcontrol$tol) \n##             stop(mstyle$stop(paste0(\"Optimizer (\", optimizer, \n##                 \") did not achieve convergence (convergence = \", \n##                 opt.res$convergence, \").\")))\n##         if (is.element(optimizer, c(\"minqa::uobyqa\", \"minqa::newuoa\", \n##             \"minqa::bobyqa\")) && opt.res$ierr != 0) \n##             stop(mstyle$stop(paste0(\"Optimizer (\", optimizer, \n##                 \") did not achieve convergence (ierr = \", opt.res$ierr, \n##                 \").\")))\n##         if (optimizer == \"nloptr::nloptr\" && !(opt.res$status >= \n##             1 && opt.res$status <= 4)) \n##             stop(mstyle$stop(paste0(\"Optimizer (\", optimizer, \n##                 \") did not achieve convergence (status = \", opt.res$status, \n##                 \").\")))\n##         if (optimizer == \"ucminf::ucminf\" && !(opt.res$convergence == \n##             1 || opt.res$convergence == 2)) \n##             stop(mstyle$stop(paste0(\"Optimizer (\", optimizer, \n##                 \") did not achieve convergence (convergence = \", \n##                 opt.res$convergence, \").\")))\n##         if (verbose > 2) {\n##             cat(\"\\n\")\n##             tmp <- capture.output(print(opt.res))\n##             .print.output(tmp, mstyle$verbose)\n##         }\n##         if (optimizer == \"nloptr::nloptr\") \n##             opt.res$par <- opt.res$solution\n##         if (optimizer == \"nlm\") \n##             opt.res$par <- opt.res$estimate\n##         opt.res$par <- ifelse(is.na(alpha), opt.res$par, alpha)\n##         H <- NA\n##         va <- matrix(NA_real_, nrow = q, ncol = q)\n##         hest <- is.na(alpha)\n##         if (any(hest) && !isTRUE(ddd$skiphes)) {\n##             if (verbose > 1) \n##                 message(mstyle$message(\"\\nComputing Hessian ...\"))\n##             H <- try(numDeriv::hessian(func = .ll.rma.ls, x = opt.res$par, \n##                 method.args = con$hessianCtrl, yi = yi, vi = vi, \n##                 X = X, Z = Z, reml = reml, k = k, pX = p, alpha.val = alpha, \n##                 verbose = FALSE, digits = digits, REMLf = con$REMLf, \n##                 link = link, mZ = mZ), silent = TRUE)\n##             if (inherits(H, \"try-error\")) {\n##                 warning(mstyle$warning(\"Error when trying to compute Hessian.\"), \n##                   call. = FALSE)\n##             }\n##             else {\n##                 H.hest <- H[hest, hest, drop = FALSE]\n##                 iH.hest <- try(suppressWarnings(chol2inv(chol(H.hest))), \n##                   silent = TRUE)\n##                 if (inherits(iH.hest, \"try-error\") || anyNA(iH.hest) || \n##                   any(is.infinite(iH.hest))) {\n##                   warning(mstyle$warning(\"Error when trying to invert Hessian.\"), \n##                     call. = FALSE)\n##                 }\n##                 else {\n##                   va[hest, hest] <- iH.hest\n##                 }\n##             }\n##         }\n##         alpha.val <- alpha\n##         alpha <- cbind(opt.res$par)\n##         if (!Z.int.only && Z.int.incl && con$scaleZ && is.na(alpha.val[1])) {\n##             alpha <- mZ %*% alpha\n##             va[!hest, ] <- 0\n##             va[, !hest] <- 0\n##             va <- mZ %*% va %*% t(mZ)\n##             va[!hest, ] <- NA\n##             va[, !hest] <- NA\n##             Z <- Zsave\n##         }\n##         att <- .set.btt(att, q, Z.int.incl, colnames(Z))\n##         m.alpha <- length(att)\n##         if (test == \"t\") {\n##             ddf.alpha <- k - q\n##         }\n##         else {\n##             ddf.alpha <- NA\n##         }\n##         QS <- try(as.vector(t(alpha)[att] %*% chol2inv(chol(va[att, \n##             att])) %*% alpha[att]), silent = TRUE)\n##         if (inherits(QS, \"try-error\")) \n##             QS <- NA\n##         se.alpha <- sqrt(diag(va))\n##         rownames(alpha) <- rownames(va) <- colnames(va) <- colnames(Z)\n##         names(se.alpha) <- NULL\n##         zval.alpha <- c(alpha/se.alpha)\n##         if (test == \"t\") {\n##             QS <- QS/m.alpha\n##             QSdf <- c(m.alpha, k - q)\n##             QSp <- if (QSdf[2] > 0) \n##                 pf(QS, df1 = QSdf[1], df2 = QSdf[2], lower.tail = FALSE)\n##             else NA\n##             pval.alpha <- if (ddf.alpha > 0) \n##                 2 * pt(abs(zval.alpha), df = ddf.alpha, lower.tail = FALSE)\n##             else rep(NA, q)\n##             crit.alpha <- if (ddf.alpha > 0) \n##                 qt(level/2, df = ddf.alpha, lower.tail = FALSE)\n##             else NA\n##         }\n##         else {\n##             QSdf <- c(m.alpha, NA)\n##             QSp <- pchisq(QS, df = QSdf[1], lower.tail = FALSE)\n##             pval.alpha <- 2 * pnorm(abs(zval.alpha), lower.tail = FALSE)\n##             crit.alpha <- qnorm(level/2, lower.tail = FALSE)\n##         }\n##         ci.lb.alpha <- c(alpha - crit.alpha * se.alpha)\n##         ci.ub.alpha <- c(alpha + crit.alpha * se.alpha)\n##         if (link == \"log\") \n##             tau2 <- exp(as.vector(Z %*% alpha))\n##         if (link == \"identity\") \n##             tau2 <- as.vector(Z %*% alpha)\n##     }\n##     if (is.element(method, c(\"FE\", \"EE\", \"CE\"))) \n##         tau2 <- 0\n##     if (verbose > 1) \n##         message(mstyle$message(\"\\nModel fitting ...\"))\n##     wi <- 1/(vi + tau2)\n##     W <- diag(wi, nrow = k, ncol = k)\n##     M <- diag(vi + tau2, nrow = k, ncol = k)\n##     if (weighted) {\n##         if (is.null(weights) || is.element(test, c(\"knha\", \"adhoc\"))) {\n##             if (any(is.infinite(wi))) \n##                 stop(mstyle$stop(\"Division by zero when computing the inverse variance weights.\"))\n##             stXWX <- .invcalc(X = X, W = W, k = k)\n##             beta <- stXWX %*% crossprod(X, W) %*% Y\n##             vb <- stXWX\n##             RSS.f <- sum(wi * (yi - X %*% beta)^2)\n##             RSS.knha <- RSS.f\n##         }\n##         if (!is.null(weights)) {\n##             A <- diag(weights, nrow = k, ncol = k)\n##             stXAX <- .invcalc(X = X, W = A, k = k)\n##             beta <- stXAX %*% crossprod(X, A) %*% Y\n##             vb <- stXAX %*% t(X) %*% A %*% M %*% A %*% X %*% \n##                 stXAX\n##             RSS.f <- sum(wi * (yi - X %*% beta)^2)\n##         }\n##         if (is.element(test, c(\"knha\", \"adhoc\"))) {\n##             if (RSS.knha <= .Machine$double.eps) {\n##                 s2w <- 0\n##             }\n##             else {\n##                 s2w <- RSS.knha/(k - p)\n##             }\n##         }\n##     }\n##     else {\n##         stXX <- .invcalc(X = X, W = diag(k), k = k)\n##         beta <- stXX %*% crossprod(X, Y)\n##         vb <- tcrossprod(stXX, X) %*% M %*% X %*% stXX\n##         RSS.f <- sum(wi * (yi - X %*% beta)^2)\n##         if (is.element(test, c(\"knha\", \"adhoc\"))) {\n##             if (any(is.infinite(wi))) \n##                 stop(mstyle$stop(\"Division by zero when computing the inverse variance weights.\"))\n##             stXWX <- .invcalc(X = X, W = W, k = k)\n##             beta.knha <- stXWX %*% crossprod(X, W) %*% Y\n##             RSS.knha <- sum(wi * (yi - X %*% beta.knha)^2)\n##             if (RSS.knha <= .Machine$double.eps) {\n##                 s2w <- 0\n##             }\n##             else {\n##                 s2w <- RSS.knha/(k - p)\n##             }\n##         }\n##     }\n##     if (verbose > 1) \n##         message(mstyle$message(\"Conducting tests of the fixed effects ...\"))\n##     if (is.element(method, c(\"FE\", \"EE\", \"CE\")) && is.element(test, \n##         c(\"knha\", \"adhoc\"))) \n##         warning(mstyle$warning(\"Knapp & Hartung method is not meant to be used in the context of FE models.\"), \n##             call. = FALSE)\n##     if (test == \"adhoc\") \n##         s2w[s2w < 1] <- 1\n##     vb <- s2w * vb\n##     if (is.element(test, c(\"knha\", \"adhoc\", \"t\"))) {\n##         ddf <- k - p\n##     }\n##     else {\n##         ddf <- NA\n##     }\n##     QM <- try(as.vector(t(beta)[btt] %*% chol2inv(chol(vb[btt, \n##         btt])) %*% beta[btt]), silent = TRUE)\n##     if (inherits(QM, \"try-error\")) \n##         QM <- NA\n##     rownames(beta) <- rownames(vb) <- colnames(vb) <- colnames(X)\n##     se <- sqrt(diag(vb))\n##     names(se) <- NULL\n##     zval <- c(beta/se)\n##     if (is.element(test, c(\"knha\", \"adhoc\", \"t\"))) {\n##         QM <- QM/m\n##         QMdf <- c(m, k - p)\n##         QMp <- if (QMdf[2] > 0) \n##             pf(QM, df1 = QMdf[1], df2 = QMdf[2], lower.tail = FALSE)\n##         else NA\n##         pval <- if (ddf > 0) \n##             2 * pt(abs(zval), df = ddf, lower.tail = FALSE)\n##         else rep(NA, p)\n##         crit <- if (ddf > 0) \n##             qt(level/2, df = ddf, lower.tail = FALSE)\n##         else NA\n##     }\n##     else {\n##         QMdf <- c(m, NA)\n##         QMp <- pchisq(QM, df = QMdf[1], lower.tail = FALSE)\n##         pval <- 2 * pnorm(abs(zval), lower.tail = FALSE)\n##         crit <- qnorm(level/2, lower.tail = FALSE)\n##     }\n##     ci.lb <- c(beta - crit * se)\n##     ci.ub <- c(beta + crit * se)\n##     if (verbose > 1) \n##         message(mstyle$message(\"Conducting heterogeneity test ...\"))\n##     if (allvipos) {\n##         if (k > p) {\n##             wi <- 1/vi\n##             W.FE <- diag(wi, nrow = k, ncol = k)\n##             stXWX <- .invcalc(X = X, W = W.FE, k = k)\n##             P <- W.FE - W.FE %*% X %*% stXWX %*% crossprod(X, \n##                 W.FE)\n##             QE <- max(0, c(crossprod(Y, P) %*% Y))\n##             QEp <- pchisq(QE, df = k - p, lower.tail = FALSE)\n##             vt <- (k - p)/.tr(P)\n##             if (is.element(method, c(\"FE\", \"EE\", \"CE\"))) {\n##                 I2 <- max(0, 100 * (QE - (k - p))/QE)\n##                 H2 <- QE/(k - p)\n##             }\n##             else {\n##                 I2 <- 100 * tau2/(vt + tau2)\n##                 H2 <- tau2/vt + 1\n##             }\n##         }\n##         else {\n##             QE <- 0\n##             QEp <- 1\n##             I2 <- 0\n##             H2 <- 1\n##             vt <- 0\n##         }\n##     }\n##     else {\n##         if (!vi0) \n##             warning(mstyle$warning(paste0(\"Cannot compute \", \n##                 ifelse(int.only, \"Q\", \"QE\"), \"-test, I^2, or H^2 when there are non-positive sampling variances in the data.\")), \n##                 call. = FALSE)\n##         vt <- NA\n##     }\n##     if (!int.only && int.incl && !is.element(method, c(\"FE\", \n##         \"EE\", \"CE\")) && model == \"rma.uni\" && !isTRUE(ddd$skipr2)) {\n##         if (verbose > 1) {\n##             message(mstyle$message(\"Fitting RE model for R^2 computation ...\"))\n##             res.RE <- try(rma.uni(yi, vi, weights = weights, \n##                 method = method, weighted = weighted, test = test, \n##                 verbose = ifelse(verbose, TRUE, FALSE), control = con, \n##                 digits = digits), silent = FALSE)\n##         }\n##         else {\n##             res.RE <- try(suppressWarnings(rma.uni(yi, vi, weights = weights, \n##                 method = method, weighted = weighted, test = test, \n##                 verbose = ifelse(verbose, TRUE, FALSE), control = con, \n##                 digits = digits)), silent = TRUE)\n##         }\n##         if (!inherits(res.RE, \"try-error\")) {\n##             tau2.RE <- res.RE$tau2\n##             if (identical(tau2.RE, 0)) {\n##                 R2 <- 0\n##             }\n##             else {\n##                 R2 <- max(0, 100 * (tau2.RE - tau2)/tau2.RE)\n##             }\n##         }\n##         else {\n##             R2 <- NA\n##         }\n##     }\n##     else {\n##         R2 <- NULL\n##     }\n##     if (verbose > 1) \n##         message(mstyle$message(\"Computing fit statistics and log likelihood ...\"))\n##     parms <- p + ifelse(model == \"rma.uni\", ifelse(is.element(method, \n##         c(\"FE\", \"EE\", \"CE\")) || tau2.fix, 0, 1), sum(is.na(alpha.val)))\n##     ll.ML <- -1/2 * (k) * log(2 * base::pi) - 1/2 * sum(log(vi + \n##         tau2)) - 1/2 * RSS.f\n##     ll.REML <- -1/2 * (k - p) * log(2 * base::pi) + ifelse(con$REMLf, \n##         1/2 * determinant(crossprod(X), logarithm = TRUE)$modulus, \n##         0) + -1/2 * sum(log(vi + tau2)) - 1/2 * determinant(crossprod(X, \n##         W) %*% X, logarithm = TRUE)$modulus - 1/2 * RSS.f\n##     if (k > p) {\n##         dev.ML <- -2 * (ll.ML - sum(dnorm(yi, mean = yi, sd = sqrt(vi), \n##             log = TRUE)))\n##     }\n##     else {\n##         dev.ML <- 0\n##     }\n##     AIC.ML <- -2 * ll.ML + 2 * parms\n##     BIC.ML <- -2 * ll.ML + parms * log(k)\n##     AICc.ML <- -2 * ll.ML + 2 * parms * max(k, parms + 2)/(max(k, \n##         parms + 2) - parms - 1)\n##     dev.REML <- -2 * (ll.REML - 0)\n##     AIC.REML <- -2 * ll.REML + 2 * parms\n##     BIC.REML <- -2 * ll.REML + parms * log(k - p)\n##     AICc.REML <- -2 * ll.REML + 2 * parms * max(k - p, parms + \n##         2)/(max(k - p, parms + 2) - parms - 1)\n##     fit.stats <- matrix(c(ll.ML, dev.ML, AIC.ML, BIC.ML, AICc.ML, \n##         ll.REML, dev.REML, AIC.REML, BIC.REML, AICc.REML), ncol = 2, \n##         byrow = FALSE)\n##     dimnames(fit.stats) <- list(c(\"ll\", \"dev\", \"AIC\", \"BIC\", \n##         \"AICc\"), c(\"ML\", \"REML\"))\n##     fit.stats <- data.frame(fit.stats)\n##     if (verbose > 1) \n##         message(mstyle$message(\"Preparing output ...\"))\n##     p.eff <- p\n##     k.eff <- k\n##     if (is.null(ddd$outlist)) {\n##         res <- list(b = beta, beta = beta, se = se, zval = zval, \n##             pval = pval, ci.lb = ci.lb, ci.ub = ci.ub, vb = vb, \n##             tau2 = tau2, se.tau2 = se.tau2, tau2.fix = tau2.fix, \n##             tau2.f = tau2, I2 = I2, H2 = H2, R2 = R2, vt = vt, \n##             QE = QE, QEp = QEp, QM = QM, QMdf = QMdf, QMp = QMp, \n##             k = k, k.f = k.f, k.eff = k.eff, k.all = k.all, p = p, \n##             p.eff = p.eff, parms = parms, int.only = int.only, \n##             int.incl = int.incl, intercept = intercept, allvipos = allvipos, \n##             coef.na = coef.na, yi = yi, vi = vi, X = X, weights = weights, \n##             yi.f = yi.f, vi.f = vi.f, X.f = X.f, weights.f = weights.f, \n##             M = M, ai.f = ai.f, bi.f = bi.f, ci.f = ci.f, di.f = di.f, \n##             x1i.f = x1i.f, x2i.f = x2i.f, t1i.f = t1i.f, t2i.f = t2i.f, \n##             ni = ni, ni.f = ni.f, ids = ids, not.na = not.na, \n##             subset = subset, slab = slab, slab.null = slab.null, \n##             measure = measure, method = method, model = model, \n##             weighted = weighted, test = test, dfs = ddf, ddf = ddf, \n##             s2w = s2w, btt = btt, m = m, digits = digits, level = level, \n##             control = control, verbose = verbose, add = add, \n##             to = to, drop00 = drop00, fit.stats = fit.stats, \n##             formula.yi = formula.yi, formula.mods = formula.mods, \n##             version = packageVersion(\"metafor\"), call = mf)\n##     }\n##     if (!is.null(ddd$outlist)) {\n##         if (ddd$outlist == \"minimal\") {\n##             res <- list(b = beta, beta = beta, se = se, zval = zval, \n##                 pval = pval, ci.lb = ci.lb, ci.ub = ci.ub, vb = vb, \n##                 tau2 = tau2, se.tau2 = se.tau2, tau2.fix = tau2.fix, \n##                 I2 = I2, H2 = H2, R2 = R2, QE = QE, QEp = QEp, \n##                 QM = QM, QMdf = QMdf, QMp = QMp, k = k, k.eff = k.eff, \n##                 p = p, p.eff = p.eff, parms = parms, int.only = int.only, \n##                 measure = measure, method = method, model = model, \n##                 test = test, dfs = ddf, ddf = ddf, btt = btt, \n##                 m = m, digits = digits, fit.stats = fit.stats)\n##         }\n##         else {\n##             res <- eval(parse(text = paste0(\"list(\", ddd$outlist, \n##                 \")\")))\n##         }\n##     }\n##     if (model == \"rma.ls\") {\n##         res$alpha <- alpha\n##         res$va <- va\n##         res$se.alpha <- se.alpha\n##         res$zval.alpha <- zval.alpha\n##         res$pval.alpha <- pval.alpha\n##         res$ci.lb.alpha <- ci.lb.alpha\n##         res$ci.ub.alpha <- ci.ub.alpha\n##         res$alpha.fix <- !is.na(alpha.val)\n##         res$q <- q\n##         res$alphas <- q\n##         res$link <- link\n##         res$Z <- Z\n##         res$Z.f <- Z.f\n##         res$tau2.f <- rep(NA, k.f)\n##         res$tau2.f[not.na] <- tau2\n##         res$att <- att\n##         res$m.alpha <- m.alpha\n##         res$ddf.alpha <- ddf.alpha\n##         res$QS <- QS\n##         res$QSdf <- QSdf\n##         res$QSp <- QSp\n##         res$formula.scale <- formula.scale\n##         res$Z.int.incl <- Z.int.incl\n##         res$Z.intercept <- Z.int.incl\n##         res$Z.int.only <- Z.int.only\n##         res$H <- H\n##     }\n##     time.end <- proc.time()\n##     res$time <- unname(time.end - time.start)[3]\n##     if (.isTRUE(ddd$time)) \n##         .print.time(res$time)\n##     if (verbose || .isTRUE(ddd$time)) \n##         cat(\"\\n\")\n##     if (model == \"rma.ls\") {\n##         class(res) <- c(\"rma.ls\", \"rma.uni\", \"rma\")\n##     }\n##     else {\n##         class(res) <- c(\"rma.uni\", \"rma\")\n##     }\n##     return(res)\n## }\n## <bytecode: 0x560d9242f6b0>\n## <environment: namespace:metafor>## Error in pw_forest_plot(): argument \"m_type\" is missing, with no default"},{"path":"pipeline.html","id":"getting-nma-data","chapter":"4 Pipeline","heading":"4.2.2 Getting NMA data","text":"Key thing need exclude single-arm studies.example:filter single-row studies, get viable observations model, empty tibble viable observations.","code":"## [1] 9## [1] 9## Error: Single-arm studies are not supported: issue with studies \"ahmed 2016\", \"carette 1994\" and \"ginsberg 1996\".## [1] 76## [1] 76"},{"path":"pipeline.html","id":"pain-intensity","chapter":"4 Pipeline","heading":"4.3 Pain intensity","text":"","code":""},{"path":"pipeline.html","id":"change-score","chapter":"4 Pipeline","heading":"4.3.1 Change score","text":"","code":"## Error: Problem with `filter()` input `..1`.\n## ℹ Input `..1` is `outcome == o`.\n## x level sets of factors are different"},{"path":"pipeline.html","id":"post-intervention","chapter":"4 Pipeline","heading":"4.3.2 Post-intervention","text":"","code":"## Error: Problem with `filter()` input `..1`.\n## ℹ Input `..1` is `outcome == o`.\n## x level sets of factors are different"},{"path":"pipeline.html","id":"adverse","chapter":"4 Pipeline","heading":"4.4 Adverse","text":"","code":"## Error: Problem with `filter()` input `..1`.\n## ℹ Input `..1` is `outcome == o`.\n## x level sets of factors are different"},{"path":"pipeline.html","id":"mood","chapter":"4 Pipeline","heading":"4.5 Mood","text":"","code":""},{"path":"pipeline.html","id":"change-score-1","chapter":"4 Pipeline","heading":"4.5.1 Change score","text":"","code":"## Error: Problem with `filter()` input `..1`.\n## ℹ Input `..1` is `outcome == o`.\n## x level sets of factors are different"},{"path":"pipeline.html","id":"post-intervention-1","chapter":"4 Pipeline","heading":"4.5.2 Post-intervention","text":"","code":"## Error: Problem with `filter()` input `..1`.\n## ℹ Input `..1` is `outcome == o`.\n## x level sets of factors are different"},{"path":"pipeline.html","id":"serious-adverse","chapter":"4 Pipeline","heading":"4.6 Serious adverse","text":"","code":"## Error: Problem with `filter()` input `..1`.\n## ℹ Input `..1` is `outcome == o`.\n## x level sets of factors are different"},{"path":"pipeline.html","id":"dropout-due-to-adverse-events","chapter":"4 Pipeline","heading":"4.7 Dropout due to adverse events","text":"","code":"## Error: Problem with `filter()` input `..1`.\n## ℹ Input `..1` is `outcome == o`.\n## x level sets of factors are different"},{"path":"pipeline.html","id":"substantial-pain","chapter":"4 Pipeline","heading":"4.8 Substantial pain","text":"","code":"## Error: Problem with `filter()` input `..1`.\n## ℹ Input `..1` is `outcome == o`.\n## x level sets of factors are different"},{"path":"pipeline.html","id":"moderate-pain","chapter":"4 Pipeline","heading":"4.9 Moderate pain","text":"","code":"## Error: Problem with `filter()` input `..1`.\n## ℹ Input `..1` is `outcome == o`.\n## x level sets of factors are different"},{"path":"pipeline.html","id":"sleep","chapter":"4 Pipeline","heading":"4.10 Sleep","text":"","code":""},{"path":"pipeline.html","id":"change-score-2","chapter":"4 Pipeline","heading":"4.10.1 Change score","text":"","code":"## Error: Problem with `filter()` input `..1`.\n## ℹ Input `..1` is `outcome == o`.\n## x level sets of factors are different"},{"path":"pipeline.html","id":"post-intervention-2","chapter":"4 Pipeline","heading":"4.10.2 Post intervention","text":"","code":"## Error: Problem with `filter()` input `..1`.\n## ℹ Input `..1` is `outcome == o`.\n## x level sets of factors are different"},{"path":"pipeline.html","id":"withdrawal","chapter":"4 Pipeline","heading":"4.11 Withdrawal","text":"","code":"## Error: Problem with `filter()` input `..1`.\n## ℹ Input `..1` is `outcome == o`.\n## x level sets of factors are different"},{"path":"pipeline.html","id":"quality-of-life","chapter":"4 Pipeline","heading":"4.12 Quality of life","text":"","code":""},{"path":"pipeline.html","id":"change-score-3","chapter":"4 Pipeline","heading":"4.12.1 Change score","text":"","code":"## Error: Problem with `filter()` input `..1`.\n## ℹ Input `..1` is `outcome == o`.\n## x level sets of factors are different"},{"path":"pipeline.html","id":"post-intervention-3","chapter":"4 Pipeline","heading":"4.12.2 Post intervention","text":"","code":"## Error: Problem with `filter()` input `..1`.\n## ℹ Input `..1` is `outcome == o`.\n## x level sets of factors are different"},{"path":"pipeline.html","id":"physical-functioning","chapter":"4 Pipeline","heading":"4.13 Physical functioning","text":"","code":""},{"path":"pipeline.html","id":"change-score-4","chapter":"4 Pipeline","heading":"4.13.1 Change score","text":"","code":"## Error: Problem with `filter()` input `..1`.\n## ℹ Input `..1` is `outcome == o`.\n## x level sets of factors are different"},{"path":"pipeline.html","id":"post-intervention-4","chapter":"4 Pipeline","heading":"4.13.2 Post intervention","text":"","code":"## Error: Problem with `filter()` input `..1`.\n## ℹ Input `..1` is `outcome == o`.\n## x level sets of factors are different"}]
